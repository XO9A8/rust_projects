//! Database operations and connection management.
//!
//! This module provides all database-related functionality including:
//! - Connection pool management
//! - Schema initialization
//! - CRUD operations for URL links
//!
//! # Database Schema
//!
//! ```sql
//! CREATE TABLE IF NOT EXISTS links (
//!     id INTEGER PRIMARY KEY AUTOINCREMENT,
//!     short_code TEXT NOT NULL UNIQUE,
//!     long_url TEXT NOT NULL
//! );
//! ```
//!
//! # Examples
//!
//! ```no_run
//! use sqlx::SqlitePool;
//!
//! # async fn example() -> Result<(), Box<dyn std::error::Error>> {
//! // Connect to database
//! let pool = db_connection("sqlite://urls.db").await?;
//!
//! // Initialize schema
//! init_db(&pool).await?;
//!
//! // Create a short link
//! create_short_link(&pool, "abc123", "https://example.com").await?;
//!
//! // Retrieve the long URL
//! let url = get_long_url(&pool, "abc123").await?;
//! # Ok(())
//! # }
//! ```

use sqlx::{Error, SqlitePool, sqlite::SqliteQueryResult};

/// SQL query to create the links table if it doesn't exist.
///
/// The table schema includes:
/// - `id`: Auto-incrementing primary key
/// - `short_code`: Unique 7-character identifier for the short URL
/// - `long_url`: The original long URL to redirect to
const CREATE_TABLE_SQL: &str = "
    CREATE TABLE IF NOT EXISTS links (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        short_code TEXT NOT NULL UNIQUE,
        long_url TEXT NOT NULL
    )
";

/// Establishes a connection to the SQLite database.
///
/// Creates a connection pool that can be shared across async tasks.
/// The database file will be created if it doesn't exist.
///
/// # Arguments
///
/// * `db_url` - SQLite connection string (e.g., "sqlite://urls.db")
///
/// # Returns
///
/// Returns a `SqlitePool` on success, or an `Error` if connection fails.
///
/// # Examples
///
/// ```no_run
/// # use sqlx::SqlitePool;
/// # async fn example() -> Result<(), sqlx::Error> {
/// let pool = db_connection("sqlite://urls.db").await?;
/// # Ok(())
/// # }
/// ```
///
/// # Errors
///
/// Returns an error if:
/// - The database URL is invalid
/// - Cannot create/open the database file
/// - Insufficient permissions
pub async fn db_connection(db_url: &str) -> Result<SqlitePool, Error> {
    SqlitePool::connect(db_url).await
}

/// Initializes the database schema by creating necessary tables.
///
/// Creates the `links` table if it doesn't already exist. This function
/// is idempotent and safe to call multiple times.
///
/// # Arguments
///
/// * `pool` - Reference to the SQLite connection pool
///
/// # Returns
///
/// Returns a `SqliteQueryResult` on success, or an error if table creation fails.
///
/// # Examples
///
/// ```no_run
/// # use sqlx::SqlitePool;
/// # async fn example(pool: &SqlitePool) -> Result<(), sqlx::Error> {
/// init_db(pool).await?;
/// # Ok(())
/// # }
/// ```
///
/// # Errors
///
/// Returns an error if the SQL execution fails due to:
/// - Database permission issues
/// - Corrupted database file
/// - Invalid SQL syntax (unlikely with const query)
pub async fn init_db(pool: &SqlitePool) -> Result<SqliteQueryResult, sqlx::Error> {
    sqlx::query(CREATE_TABLE_SQL).execute(pool).await
}

/// Creates a new short link entry in the database.
///
/// Inserts a mapping between a short code and a long URL into the links table.
/// The short code must be unique - attempting to insert a duplicate will result in an error.
///
/// # Arguments
///
/// * `pool` - Reference to the SQLite connection pool
/// * `short_code` - The unique 7-character identifier (typically generated by nanoid)
/// * `long_url` - The original long URL to be shortened
///
/// # Returns
///
/// Returns a `SqliteQueryResult` containing information about the insertion,
/// or an error if the operation fails.
///
/// # Examples
///
/// ```no_run
/// # use sqlx::SqlitePool;
/// # async fn example(pool: &SqlitePool) -> Result<(), sqlx::Error> {
/// create_short_link(pool, "kN3pL4m", "https://www.rust-lang.org/").await?;
/// # Ok(())
/// # }
/// ```
///
/// # Errors
///
/// Returns an error if:
/// - The short code already exists (UNIQUE constraint violation)
/// - Database connection is lost
/// - Invalid SQL parameter binding
pub async fn create_short_link(
    pool: &SqlitePool,
    short_code: &str,
    long_url: &str,
) -> Result<SqliteQueryResult, Error> {
    sqlx::query("INSERT INTO links (short_code, long_url) VALUES (?, ?)")
        .bind(short_code)
        .bind(long_url)
        .execute(pool)
        .await
}

/// Retrieves the long URL associated with a short code.
///
/// Queries the database for the original long URL mapped to the given short code.
/// This is used to redirect users from short URLs to their destinations.
///
/// # Arguments
///
/// * `pool` - Reference to the SQLite connection pool
/// * `short_code` - The 7-character identifier to look up
///
/// # Returns
///
/// Returns the long URL as a `String` on success, or an error if not found.
///
/// # Examples
///
/// ```no_run
/// # use sqlx::SqlitePool;
/// # async fn example(pool: &SqlitePool) -> Result<(), sqlx::Error> {
/// let long_url = get_long_url(pool, "kN3pL4m").await?;
/// println!("Redirecting to: {}", long_url);
/// # Ok(())
/// # }
/// ```
///
/// # Errors
///
/// Returns an error if:
/// - No entry exists with the given short code (RowNotFound)
/// - Database connection is lost
/// - Query execution fails
pub async fn get_long_url(pool: &SqlitePool, short_code: &str) -> Result<String, Error> {
    sqlx::query_scalar("SELECT long_url FROM links WHERE short_code = ?")
        .bind(short_code)
        .fetch_one(pool)
        .await
}
